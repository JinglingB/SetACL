/////////////////////////////////////////////////////////////////////////////
//
//
//	SetACL.odl
//
//
//	Description:	IDL source code for the ActiveX control project
//
//	Author:			Helge Klein
//
//	Created with:	MS Visual C++ 8.0
//
// Required:		Headers and libs from the platform SDK
//
//	Tabs set to:	3
//
//
/////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
//
// Includes
//
//////////////////////////////////////////////////////////////////////


#include <olectl.h>
#include <idispids.h>


//////////////////////////////////////////////////////////////////////
//
// IDL "language"
//
//////////////////////////////////////////////////////////////////////


[
	uuid (34052989-CA79-44A1-8E31-31A6F14B21F6),
	version (1.0),
	helpstring ("SetACL ActiveX Control"),
	control
]

library SETACLLib
{
	importlib (STDOLE_TLB);
	importlib (STDTYPE_TLB);

	//
	//  Primary dispatch interface for CSetACLCtrl
	//

	[
		uuid (85869435-0EE3-440B-BF69-6C52C6638073),
		helpstring ("Dispatch interface for SetACL ActiveX Control"),
		hidden
	]
	
	dispinterface _DSetACL
	{
		properties:

		methods:

			[id(1),	helpstring ("Dummy - do not use"), hidden]
						void Dummy1();
			[id(2),	helpstring ("Dummy - do not use"), hidden]
						void Dummy2();
			[id(3),	helpstring ("Dummy - do not use"), hidden]
						void Dummy3();
			[id(4),	helpstring ("Dummy - do not use"), hidden]
						void Dummy4();
			[id(5),	helpstring ("Dummy - do not use"), hidden]
						void Dummy5();
			[id(6),	helpstring ("Dummy - do not use"), hidden]
						void Dummy6();
			[id(7),	helpstring ("Dummy - do not use"), hidden]
						void Dummy7();
			[id(8),	helpstring ("Add an ACE to a DACL or SACL")]
						LONG AddACE(BSTR sTrustee, VARIANT_BOOL fTrusteeIsSID, BSTR sPermission, LONG nInheritance, VARIANT_BOOL fInhSpecified, LONG nAccessMode, LONG nACLType);
			[id(9),	helpstring ("Add a trustee: used by the functions to remove/replace (a) specified trustee(s) from the ACL")]
						LONG AddTrustee(BSTR sTrustee, BSTR sNewTrustee, VARIANT_BOOL fTrusteeIsSID, VARIANT_BOOL fNewTrusteeIsSID, LONG nAction, VARIANT_BOOL fDACL, VARIANT_BOOL fSACL);
			[id(10),	helpstring ("Add a domain: used by the functions to remove/replace (a) specified domain(s) from the ACL")]
						LONG AddDomain(BSTR sDomain, BSTR sNewDomain, LONG nAction, VARIANT_BOOL fDACL, VARIANT_BOOL fSACL);
			[id(11),	helpstring ("Set the owner")]
						LONG SetOwner(BSTR sTrustee, VARIANT_BOOL fTrusteeIsSID);
			[id(12),	helpstring ("Set the primary group")]
						LONG SetPrimaryGroup(BSTR sTrustee, VARIANT_BOOL fTrusteeIsSID);
			[id(13),	helpstring ("Set the options for ACL listing")]
						LONG SetListOptions(LONG nListFormat, LONG nListWhat, VARIANT_BOOL fListInherited, LONG nListNameSID);
			[id(14),	helpstring ("Set the action to be performed")]
						LONG SetAction(LONG nAction);
			[id(15),	helpstring ("Specify a (unicode) file to be used for logging")]
						LONG SetLogFile(BSTR sLogFile);
			[id(16),	helpstring ("Do it: apply all settings.")]
						LONG Run(void);
			[id(17), helpstring ("Retrieve a resource string (used for error messages) identified by ID")]
						BSTR GetResourceString(LONG nID);
			[id(18), helpstring ("Retrieve the last API error as a localized string")]
						BSTR GetLastAPIErrorMessage(void);
			[id(19), helpstring ("Retrieve the last API error as an error number")]
						LONG GetLastAPIError(void);
			[id(20), helpstring ("Retrieve the last output generated by the list function")]
						BSTR GetLastListOutput (void);
			[id(21), helpstring ("Reset the object to its initial state")]
						void Reset (void);
			[id(22),	helpstring ("Set the options for ACL listing")]
						LONG SetListOptions2(LONG nListFormat, LONG nListWhat, VARIANT_BOOL fListInherited, LONG nListNameSID, VARIANT_BOOL fListCleanOutput);
			[id(23),	helpstring ("Should execution continue if errors occur?")]
						VARIANT_BOOL SetIgnoreErrors(VARIANT_BOOL fIgnoreErrors);
			[id(24),	helpstring ("Set the object on which all actions are to be performed")]
						LONG SetObject(BSTR sObjectPath, LONG nObjectType);
			[id(25),	helpstring ("Add an action to be performed")]
						LONG AddAction(LONG nAction);
			[id(26),	helpstring ("Should we recurse?")]
						LONG SetRecursion(LONG nRecursionType);
			[id(27),	helpstring ("Set flags specific to the object")]
						LONG SetObjectFlags(LONG nDACLProtected, LONG nSACLProtected, VARIANT_BOOL fDACLResetChildObjects, VARIANT_BOOL fSACLResetChildObjects);
			[id(28),	helpstring ("Specify a (unicode) file to be used for backup/restore operations")]
						LONG SetBackupRestoreFile(BSTR sBackupRestoreFile);
			[id(29),	helpstring ("Add a keyword to be filtered out - objects containing this keyword are not processed")]
						void AddObjectFilter(BSTR sKeyword);
			[id(30),	helpstring ("Send message events (default: no)?")]
						VARIANT_BOOL SendMessageEvents(VARIANT_BOOL fSendEvents);
	};

	//
	// All constant definitions to be placed here
	//

	[
		uuid (195DB491-1BA5-4857-9BD0-B6A92064C978),
		helpstring ("Contains constant definitions used by SetACL")
	]

	// ACL/SD information types
	typedef enum _SDINFO
	{
		[helpstring ("Process the DACL (permission information)")]
			ACL_DACL					=	1,
		[helpstring ("Process the SACL (auditing information)")]
			ACL_SACL					=	2,
		[helpstring ("Owner information")]
			SD_OWNER					=	4,
		[helpstring ("Primary group information")]
			SD_GROUP					=	8
	} SDINFO;

	// Actions the program can perform
	typedef enum _ACTIONS
	{
		[helpstring ("Add an ACE")]
			ACTN_ADDACE				=	1,
		[helpstring ("List the entries in the security descriptor")]
			ACTN_LIST				=	2,
		[helpstring ("Set the owner")]
			ACTN_SETOWNER			=	4,
		[helpstring ("Set the primary group")]
			ACTN_SETGROUP			=	8,
		[helpstring ("Clear the DACL of any non-inherited ACEs")]
			ACTN_CLEARDACL			=	16,
		[helpstring ("Clear the SACL of any non-inherited ACEs")]
			ACTN_CLEARSACL			=	32,
		[helpstring ("Set the flag 'allow inheritable permissions from the parent object to propagate to this object'")]
			ACTN_SETINHFROMPAR	=	64,
		[helpstring ("Reset permissions on all sub-objects and enable propagation of inherited permissions")]
			ACTN_RESETCHILDPERMS	=	128,
		[helpstring ("Replace one trustee by another in all ACEs")]
			ACTN_REPLACETRUSTEE	=	256,
		[helpstring ("Remove all ACEs belonging to a certain trustee")]
			ACTN_REMOVETRUSTEE	=	512,
		[helpstring ("Copy the permissions for one trustee to another")]
			ACTN_COPYTRUSTEE		=	1024,
		[helpstring ("Replace one domain by another in all ACEs")]
			ACTN_REPLACEDOMAIN	=	256,
		[helpstring ("Remove all ACEs belonging to a certain domain")]
			ACTN_REMOVEDOMAIN		=	512,
		[helpstring ("Copy the permissions for one domain to another")]
			ACTN_COPYDOMAIN		=	1024,
		[helpstring ("Restore entire security descriptors backup up with the list function")]
			ACTN_RESTORE			=	2048,
		[helpstring ("Process all trustee actions")]
			ACTN_TRUSTEE			=	4096,
		[helpstring ("Process all domain actions")]
			ACTN_DOMAIN				=	8192
	} ACTIONS;

	// Return/Error codes
	typedef enum _RETCODES
	{
		[helpstring ("OK")]
			RTN_OK									=	0,
		[helpstring ("Usage instructions were printed")]
			RTN_USAGE								=	1,
		[helpstring ("General error")]
			RTN_ERR_GENERAL						=	2,
		[helpstring ("Parameter(s) incorrect")]
			RTN_ERR_PARAMS							=	3,
		[helpstring ("The object was not set")]
			RTN_ERR_OBJECT_NOT_SET				=	4,
		[helpstring ("The call to GetNamedSecurityInfo () failed")]
			RTN_ERR_GETSECINFO					=	5,
		[helpstring ("The SID for a trustee could not be found")]
			RTN_ERR_LOOKUP_SID					=	6,
		[helpstring ("Directory permissions specified are invalid")]
			RTN_ERR_INV_DIR_PERMS				=	7,
		[helpstring ("Printer permissions specified are invalid")]
			RTN_ERR_INV_PRN_PERMS				=	8,
		[helpstring ("Registry permissions specified are invalid")]
			RTN_ERR_INV_REG_PERMS				=	9,
		[helpstring ("Service permissions specified are invalid")]
			RTN_ERR_INV_SVC_PERMS				=	10,
		[helpstring ("Share permissions specified are invalid")]
			RTN_ERR_INV_SHR_PERMS				=	11,
		[helpstring ("A privilege could not be enabled")]
			RTN_ERR_EN_PRIV						=	12,
		[helpstring ("A privilege could not be disabled")]
			RTN_ERR_DIS_PRIV						=	13,
		[helpstring ("No notification function was given")]
			RTN_ERR_NO_NOTIFY						=	14,
		[helpstring ("An error occured in the list function")]
			RTN_ERR_LIST_FAIL						=	15,
		[helpstring ("FindFile reported an error")]
			RTN_ERR_FINDFILE						=	16,
		[helpstring ("GetSecurityDescriptorControl () failed")]
			RTN_ERR_GET_SD_CONTROL				=	17,
		[helpstring ("An internal program error occured")]
			RTN_ERR_INTERNAL						=	18,
		[helpstring ("SetEntriesInAcl () failed")]
			RTN_ERR_SETENTRIESINACL				=	19,
		[helpstring ("A registry path is incorrect")]
			RTN_ERR_REG_PATH						=	20,
		[helpstring ("Connect to a remote registry failed")]
			RTN_ERR_REG_CONNECT					=	21,
		[helpstring ("Opening a registry key failed")]
			RTN_ERR_REG_OPEN						=	22,
		[helpstring ("Enumeration of registry keys failed")]
			RTN_ERR_REG_ENUM						=	23,
		[helpstring ("Preparation failed")]
			RTN_ERR_PREPARE						=	24,
		[helpstring ("The call to SetNamedSecurityInfo () failed")]
			RTN_ERR_SETSECINFO					=	25,
		[helpstring ("Incorrect list options specified")]
			RTN_ERR_LIST_OPTIONS					=	26,
		[helpstring ("A SD could not be converted to/from string format")]
			RTN_ERR_CONVERT_SD					=	27,
		[helpstring ("ACL listing failed")]
			RTN_ERR_LIST_ACL						=	28,
		[helpstring ("Looping through an ACL failed")]
			RTN_ERR_LOOP_ACL						=	29,
		[helpstring ("Deleting an ACE failed")]
			RTN_ERR_DEL_ACE						=	30,
		[helpstring ("Copying an ACL failed")]
			RTN_ERR_COPY_ACL						=	31,
		[helpstring ("Adding an ACE failed")]
			RTN_ERR_ADD_ACE						=	32,
		[helpstring ("No backup/restore file was specified")]
			RTN_ERR_NO_LOGFILE					=	33,
		[helpstring ("The backup/restore file could not be opened")]
			RTN_ERR_OPEN_LOGFILE					=	34,
		[helpstring ("A read operation from the backup/restore file failed")]
			RTN_ERR_READ_LOGFILE					=	35,
		[helpstring ("A write operation from the backup/restore file failed")]
			RTN_ERR_WRITE_LOGFILE				=	36,
		[helpstring ("The operating system is not supported")]
			RTN_ERR_OS_NOT_SUPPORTED			=	37,
		[helpstring ("The security descriptor is invalid")]
			RTN_ERR_INVALID_SD					=	38,
		[helpstring ("The call to SetSecurityDescriptorDacl () failed")]
			RTN_ERR_SET_SD_DACL					=	39,
		[helpstring ("The call to SetSecurityDescriptorSacl () failed")]
			RTN_ERR_SET_SD_SACL					=	40,
		[helpstring ("The call to SetSecurityDescriptorOwner () failed")]
			RTN_ERR_SET_SD_OWNER					=	41,
		[helpstring ("The call to SetSecurityDescriptorGroup () failed")]
			RTN_ERR_SET_SD_GROUP					=	42,
		[helpstring ("The domain specified is invalid")]
			RTN_ERR_INV_DOMAIN					=	43,
		[helpstring ("An error occured, but it was ignored")]
			RTN_ERR_IGNORED						=	44,
		[helpstring ("The creation of an SD failed")]
			RTN_ERR_CREATE_SD						=	45,
		[helpstring ("Memory allocation failed")]
			RTN_ERR_OUT_OF_MEMORY				=	46,
		[helpstring ("No action specified - nothing to do")]
			RTN_ERR_NO_ACTN_SPECIFIED			=	47,
		[helpstring ("WMI permissions specified are invalid")]
			RTN_ERR_INV_WMI_PERMS				=	48,
		[helpstring ("Recursion is not possible")]
			RTN_WRN_RECURSION_IMPOSSIBLE		=	49,
	} RETCODES;

	// For inheritance from the parent
	typedef enum _INHERITANCE
	{
		[helpstring ("Do not change settings")]
			INHPARNOCHANGE							=	0,
		[helpstring ("Inherit from parent")]
			INHPARYES								=	1,
		[helpstring ("Do not inherit, copy inheritable permissions")]
			INHPARCOPY								=	2,
		[helpstring ("Do not inherit, do not copy inheritable permissions")]
			INHPARNOCOPY							=	4
	} INHERITANCE;

	// For propagation to child objects
	typedef enum _PROPAGATION
	{
		[helpstring ("The specific access permissions will only be applied to the container, and will not be inherited by objects created within the container.")]
		NO_INHERITANCE								= 0,
		[helpstring ("The specific access permissions will only be inherited by objects created within the specific container. The access permissions will not be applied to the container itself.")]
		SUB_OBJECTS_ONLY_INHERIT				= 1,
		[helpstring ("The specific access permissions will be inherited by containers created within the specific container, will be applied to objects created within the container, but will not be applied to the container itself.")]
		SUB_CONTAINERS_ONLY_INHERIT			= 2,
		[helpstring ("Combination of SUB_OBJECTS_ONLY_INHERIT and SUB_CONTAINERS_ONLY_INHERIT.")]
		SUB_CONTAINERS_AND_OBJECTS_INHERIT	= 3,
		[helpstring ("Do not propogate permissions, only the direct descendent gets permissions.")]
		INHERIT_NO_PROPAGATE						= 4,
		[helpstring ("The specific access permissions will not affect the object they are set on but its childern only (depending on other propagation flags).")]
		INHERIT_ONLY								= 8
	} PROPAGATION;

	// List formats
	typedef enum _LISTFORMATS
	{
		[helpstring ("SDDL format")]
			LIST_SDDL								=	0,
		[helpstring ("CSV format")]
			LIST_CSV									=	1,
		[helpstring ("Tabular format")]
			LIST_TAB									=	2
	} LISTFORMATS;

	// How to list trustees
	typedef enum _LISTNAMES
	{
		[helpstring ("List names")]
			LIST_NAME								=	1,
		[helpstring ("List SIDs")]
			LIST_SID									=	2,
		[helpstring ("List names and SIDs")]
			LIST_NAME_SID							=	3
	} LISTNAMES;

	// For recursion
	typedef enum _RECURSION
	{
		[helpstring ("Do not recurse")]
			RECURSE_NO								=	1,
		[helpstring ("Recurse, processing containers only")]
			RECURSE_CONT							=	2,
		[helpstring ("Recurse, processing objects only")]
			RECURSE_OBJ								=	4,
		[helpstring ("Recurse, processing containers and objects")]
			RECURSE_CONT_OBJ						=	6
	} RECURSION;

	// _SE_OBJECT_TYPE
	typedef enum _SE_OBJECT_TYPE
	{
		[helpstring ("Files/directories")]
			SE_FILE_OBJECT							=	1,
		[helpstring ("Services")]
			SE_SERVICE								=	2,
		[helpstring ("Printers")]
			SE_PRINTER								=	3,
		[helpstring ("Registry keys")]
			SE_REGISTRY_KEY						=	4,
		[helpstring ("Network shares")]
			SE_LMSHARE								=	5,
		[helpstring ("WMI Namespace")]
			SE_WMIGUID_OBJECT  				   =	11
	} SE_OBJECT_TYPE;

	// _ACCESS_MODE
	typedef enum _ACCESS_MODE
	{
		[helpstring ("Adds an access allowed ACE for the specified user/group.")]
			GRANT_ACCESS							=	1,
		[helpstring ("Replaces all existing access allowed ACEs for the specified user/group with a new ACE.")]
			SET_ACCESS								=	2,
		[helpstring ("Adds an access denied ACE for the specified user/group.")]
			DENY_ACCESS								=	3,
		[helpstring ("All existing access allowed ACEs or system audit ACEs for the specified user/group are removed.")]
			REVOKE_ACCESS							=	4,
		[helpstring ("Adds an audit success ACE for the specified user/group.")]
			SET_AUDIT_SUCCESS						=	5,
		[helpstring ("Adds an audit failure ACE for the specified user/group.")]
			SET_AUDIT_FAILURE						=	6
	} ACCESS_MODE;

	//
	//  Event dispatch interface for CSetACLCtrl
	//

	[
		uuid (89C18363-08F5-4FF7-9C82-FE75792F4C3F),
		helpstring ("Event interface for SetACL ActiveX Control")
	]

	dispinterface _DSetACLEvents
	{
		properties:

		methods:

		[id(1),	helpstring ("Receives string messages that would appear on the screen in the command line version.")]
					void MessageEvent(BSTR sMessage);
	};

	//  Class information for CSetACLCtrl

	[
		uuid(17738736-8831-4197-ACA5-A740A050B4CF),
		helpstring ("SetACL ActiveX Control"),
		control
	]

	coclass SetACL
	{
		[default]			dispinterface _DSetACL;
		[default, source]	dispinterface _DSetACLEvents;
	};
};
